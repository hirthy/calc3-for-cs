Much of the code used within this assignment is Ruby version 1.9.x.
Since it is, for most intents and purposes, a lesser known language than say, Java,
we felt it necessary to explain bits of the language which might surface in the code
we wrote for this project.

First and foremost, Ruby shares many similarites with, and is inspired by, Lisp, Smalltalk, and Perl (most likely in that order).
It contains many of the niceties of functional programming that Lisp does,
it is truly object oriented in the same way Smalltalk is,
and it is a terse scripting language with powerful features like Perl is.

Notations that might seem confusing unless one has a background in all three of these languages are such:

\begin{description}

\item[Basic Syntax]

  Comments are preceded by a \texttt{\#}.
  Strings are wrapped in either single- or double-quotes.
  Indentation is two spaces.
  Rather than using indentation-based block delimiters or curly braces,
  Ruby simply uses the end keyword.

\item[Blocks]

  Blocks are notations for anonymous functions in Ruby (like lambda in Lisp).
  They can be written a number of ways, such as:
  
  \begin{lstlisting}[language=ruby]
    # Assigning a lambda/proc to a variable, and then calling it
    f = ->(x){ x + 1 }
    f[2] #=> 3

    # Array#map is one of several functions which takes a block as an argument
    a = [1,2,3]
    a.map { |i| i * i } #=> [1,4,9]

    # This is the expanded form of the block, used for creating multi-line anonymous functions
    a.each do |item|
      puts item
    end
    # would print 1, 2, and 3 on separate lines
  \end{lstlisting}
  
\item[Ranges]
  
  Ranges are represented in Ruby with one of two operators, \texttt{..} or \texttt{...}.
  \texttt{0..10} is an inclusive range ($[0,10]$) in a more mathematical notation,
  whereas \texttt{0...5} is exclusive ($[0,5)$).
  Ranges can be iterated across.
  
\item[Method Invocation]

  In Ruby, method invocation has optional parens.
  Rather than using the form \texttt{instance.method(arg1, arg2)},
  one can use the form \texttt{instance.method arg1, arg2}.
  In the case where an invocation doesn't have arguments,
  the parentheses are still optional.

\item[Object Oriented]

  Ruby, like Smalltalk, is object oriented down to the primitives of the language.
  This means that all things in Ruby are objects, and thus have methods that can
  operate on them.
  This library was written to make use of this, monkey-patching functionality into
  the existing Matrix and Vector classes in Ruby.

\item[Notation]

  Ruby has a common nomenclature for expressing its classes and their methods.
  \texttt{Object\#method} is the de facto standard among Rubyists, hence, that's the form
  we'll use here.
  Similarly, \texttt{\#=$>$} is used to denote return values.

\item[Further Notes]

  Ruby's Matrix and Vector classes lack \texttt{\#[]=} methods, therefore, we often convert
  these two datatypes to arrays and back again to perform matrix or vector arithmetic
  or other operations.

\end{description}

Hopefully, that should clear up any misconceptions or confusion before addressing the actual
code at hand.
That said, all three parts of this report do make use of both some standard libraries in Ruby,
as well as extensions upon them.

\begin{itemize}

\item http://www.ruby-doc.org/core/classes/Array.html
\item http://www.ruby-doc.org/core/classes/Matrix.html
\item http://www.ruby-doc.org/core/classes/Vector.html

\end{itemize}

Additionally, we wrote an abstraction layer into some of these classes via monkeypatching in order
to add some common functionality:

\lstset{caption=Common Code for All Three Parts}
\begin{lstlisting}[language=ruby]

class Vector
  private
  def sign(x)
    return 1 if x > 0
    return -1 if x < 0
    return 0
  end
end

class Matrix
  def pretty_print
    str = ""
    self.to_a.each do |row|
      row.each do |i|
        if i.to_i >= 0
          str << " "
        end
        if ("%.3f" % i).to_f == i.to_i
          str << "#{i.to_i}     "
        else
          str << "%.3f " % i
        end
      end
      str << "\n"
    end
    puts str
  end

  def inf_norm
    self.to_a.map do |a|
      a.map do |ar|
        ar.abs
      end.inject(&:+)
    end.sort[0]
  end

  def is_lower_triangular?
    triangular(self.column_vectors)
  end

  def is_upper_triangular?
    triangular(self.row_vectors)
  end

  private
  def triangular(vecs)
    for i in 0...vecs.length
      vec = vecs[i].to_a
      unless i <= 1
        return false unless vec[0...i].all? { |n| n == 0 } and vec[i..-1].all? { |n| n != 0 }
      end
    end
    return true
  end
end
\end{lstlisting}
