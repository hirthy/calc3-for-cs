\documentclass[letterpaper,11pt]{article}

\usepackage{color}

\usepackage{listings}
\lstset{tabsize=2,language=ruby,morecomment=[l]{//},basicstyle=\footnotesize}

\author{Will Farrington, Jeff Drasher, Mike Hirth}
\title{Calculus 3 for Computer Science Project}

\begin{document}

\maketitle
\tableofcontents
\newpage
\section{Introduction}

Much of the code used within this assignment is Ruby version 1.9.x.
Since it is, for most intents and purposes, a lesser known language than say, Java,
we felt it necessary to explain bits of the language which might surface in the code
we wrote for this project.

First and foremost, Ruby shares many similarites with, and is inspired by, Lisp, Smalltalk, and Perl (most likely in that order).
It contains many of the niceties of functional programming that Lisp does,
it is truly object oriented in the same way Smalltalk is,
and it is a terse scripting language with powerful features like Perl is.

Notations that might seem confusing unless one has a background in all three of these languages are such:

\begin{description}

\item[Blocks]

  Blocks are notations for anonymous functions in Ruby (like lambda in Lisp).
  They can be written a number of ways, such as:
  
  \begin{lstlisting}[language=ruby]
    f = ->(x){ x + 1 }
    f[2] #=> 3

    a = [1,2,3]
    a.map { |i| i * i } #=> [1,4,9]

    a.each do |item|
      puts item
    end
    # would print 1, 2, and 3 on separate lines
  \end{lstlisting}
  
\item[Ranges]
  
  Ranges are represented in Ruby with one of two operators, .. or ... .
  0..10 is an inclusive range ($[0,10]$) in a more mathematical notation,
  whereas 0...5 is exclusive ($[0,10)$).
  Ranges can be iterated across.
  
\item[Method Invocation]

  In Ruby, method invocation has optional parens.
  Rather than using the form instance.method(arg1, arg2),
  one can use the form instance.method arg1, arg2.
  In the case where an invocation doesn't have arguments,
  the parentheses are still optional.

\item[Object Oriented]

  Ruby, like Smalltalk, is object oriented down to the primitives of the language.
  This means that all things in Ruby are objects, and thus have methods that can
  operate on them.
  This library was written to make use of this, monkey-patching functionality into
  the existing Matrix and Vector classes in Ruby.

\item[Notation]

  Ruby has a common nomenclature for expressing its classes and their methods.
  Object\#method is the de facto standard among Rubyists, hence, that's the form
  we'll use here.

\item[Further Notes]

  Ruby's Matrix and Vector classes lack \#[]= methods, therefore, we often convert
  these two datatypes to arrays and back again to perform matrix or vector arithmetic
  or other operations.

\end{description}

\newpage
\section{Part One}

The purpose of Part One of the project is to solve the typical $A\vec{x} = \vec{b}$ equation, with $A$ being a Hilbert matrix.
A Hilbert matrix is a square matrix whose elements follow the form $$H_{ij} = \frac{1}{i + j - 1}$$.

Often times, simplifying a single matrix $A$ into two or more matrices (in the case of these algorithms,
$LU$ or $QR$) and then solve.
Such algorithms introduce the potential for error, namely because they are modified forms of the original matrix.

\subsection{LU Decomposition}

Lots of stuff about LU Decomp.

\lstset{caption=LU Decomposition}
\begin{lstlisting}[language=ruby]
class Matrix
  def lu_decomposition
    return nil unless self.square?
    n = self.row_size
    a = self
    l_n = []
    cvs = a.column_vectors.map { |v| v.to_a }
    for k in 0...cvs.length
      for j in 0...cvs.length
        l_new = Matrix.identity(n).to_a
        if l_new[j][k] == 1 || j < k
          next
        end
        l_new[j][k] = - (cvs[k][j] / cvs[k][k])
        l_n << l_new
        a = Matrix[*l_new] * Matrix[*cvs.transpose]
        cvs = a.column_vectors.map { |v| v.to_a }
      end
    end
    l_final = l_n.map { |m| Matrix[*m].inverse }.inject(&:*)
    u_final = a
    return l_final,u_final
  end
end
\end{lstlisting}

\subsection{Householder Reflections}

Lots of stuff about Householder Reflections.

\lstset{caption=QR Decomposition via Householder Reflections}
\begin{lstlisting}[language=ruby]
class Matrix
  def householder
    return nil unless self.square?
    current_iteration = self
    init_dim = self.row_size
    h_list = []
    cv = current_iteration.column_vectors[0]
    h = (cv.find_householder_reflection - Matrix.identity(cv.size)).expand_to_dimensions(init_dim,init_dim) + Matrix.identity(init_dim)
    h_list << h
    current_iteration = h * current_iteration
    for i in 0...self.row_size
      cv = current_iteration.get_column_vector(i+1)
      break if cv.size < 2 || current_iteration.is_upper_triangular?
      h = (cv.find_householder_reflection - Matrix.identity(cv.size)).expand_to_dimensions(init_dim,init_dim) + Matrix.identity(init_dim)
      h_list << h
      current_iteration = h * current_iteration
    end
    q,r = h_list.inject(&:*), current_iteration
    return q,r
  end

  def expand_to_dimensions(x,y)
    curr_x, curr_y, a = self.row_size, self.column_size, self.to_a
    a.each_index do |row|
      for i in 0...(y - curr_y)
        a[row] = a[row].insert(0,0)
      end
    end
    for i in 0...(x - curr_x)
      a = a.insert(0,Array.new(y){0})
    end
    return Matrix.rows(a)
  end

  def get_column_vector(x)
    return Vector.elements(self.column(x)[x..-1])
  end
end

class Vector
  def find_householder_reflection
    a = self.to_a
    a = a[0] if a[0].is_a?(Array)
    a[0] = a[0] + sign(a[0]) * self.r
    u = Vector[*a]
    norm_u_sqrd = u.r**2
    uut = u.covector.transpose * u.covector
    h = Matrix.identity(uut.row_size) - (uut * (2 / norm_u_sqrd))
    return h
  end
end
\end{lstlisting}

\subsection{Givens Rotations}

Lots of stuff about Givens Rotations.

\lstset{caption=QR Decomposition via Givens Rotations}
\begin{lstlisting}
class Matrix
  def givens
    return nil unless self.square?
    n = self.row_size
    a = self
    g_n = []
    cvs = a.column_vectors.map { |v| v.to_a }
    for i in 0...cvs.length
      for j in 0...cvs.length
        next unless j > i
        g = Matrix.identity(n).to_a
        c = cvs[i][i] / Math.sqrt(cvs[i][i]**2 + cvs[i][j]**2)
        s = -cvs[i][j] / Math.sqrt(cvs[i][i]**2 + cvs[i][j]**2)
        g[i][i], g[j][j] = c, c
        g[j][i], g[i][j] = s, -s
        g = Matrix[*g]
        g_n << g
        a = g * a
        cvs = a.column_vectors.map { |v| v.to_a }
      end
    end
    q,r = g_n.map { |m| m.t }.inject(&:*), a
    return q,r
  end
end
\end{lstlisting}

\newpage
\section{Part Two}

Clusterfuck.

\subsection{Jacobi Method}

Lots of stuff about Jacobi Method.

\subsection{Gauss-Seidel Method}

Lots of stuff about Gauss-Seidel Method.

\newpage
\section{Part Three}

Less of a clusterfuck.

\subsection{Leslie Matrices}

Also stuff.

\subsection{Power Method}

Stuff galore.

\end{document}